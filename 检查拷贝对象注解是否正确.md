# 检查
在开始运行之前检查所有的注解拷贝对象，是否正确

如下类：
```java
class AClass{
    String name;
    String password;
    List<Object> list;
}
@CopyFrom(fromClass = AClass.calss, Fields={"name","list"})
class BClass{
    String name;
    String type;
    List<Object> list;
}
@CopyFrom(fromClass = BClass.calss, Fields={"list", "type"})
class CClass{
    String type;
    List<Object> list;
}
```
执行流程:
1. 将所有的类都扫描进Class[1...n]
2. 获取所有Class[1..n]中的具有拷贝注解的类NCClass[1..m]
3. 对NCClass[i], 1<=i<=m. 进行判断
    1. 读取注解内容的fromClass，Fields[1..j]
    2. 读取fromClass的属性集合fcFields[1...k]
    3. 判断Fields[i],1<=i<=j. 是否存在集合fcFields[1...k]中。 如果不存在 表示配置错误，提示错误。（退出或者扫描完成后退出）并抛出异常。如果全部存在，表示配置成功，提升成功并退出。

## 分析：
对于时间复杂度：在3.3中需要判断j个元素是否在,k个元素中。考虑使用HashSet存放fcFields[1..k],每次时间为O(1). j个元素需要O(j). 而扫描所有的类需要n次查询，分离出有注解的类需要m次比较。共有m个类故总时间复杂度满足 n + m + m*max{j, k}。

由于 n >= m.故化简为O(n + m*max{j, k}),max{j, k}表示对NCClass[1..n] 以及取出的每个fromClass 中最多的属性的那个类的属性个数。
    