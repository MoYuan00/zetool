以下只谈论深拷贝的实现：
## 两种大类别间的拷贝
1. 同类间的拷贝
```java
class AClass{
}
```
AClass newA = clone(new AClass());

2. 不同类间的拷贝
```java
class AClass{
    String name;
    String password;
}
@CopyFrom(class = AClass.calss, Fields={"name"})
class BClass{
    String name;
}
```
BClass 可以从AClass拷贝而来
BClass 中的name属性 需要拷贝

## 前提条件
>对于同类拷贝： final类型不拷贝，static 变量不拷贝.

>拷贝类必须具有默认构造函数
## 具体的不同情况
### 不同类拷贝问题
1. Collection 集合类型拷贝
```java
class AClass{
    String name;
    String password;
    List<Object> list;
}
@CopyFrom(class = AClass.calss, Fields={"name","list"})
class BClass{
    String name;
    List<Object> list;
}
```
对于类中某个属性`List<Object> list`需要拷贝时
要依次对list[i]进行拷贝 

2. 传递拷贝
```java
class AClass{
    String name;
    String password;
    List<Object> list;
}
@CopyFrom(class = AClass.calss, Fields={"name","list"})
class BClass{
    String name;
    String type;
    List<Object> list;
}
@CopyFrom(class = BClass.calss, Fields={"list", "type"})
class CClass{
    String type;
    List<Object> list;
}
```
>简单解决方案，将传递拷贝分成多次拷贝AClass->BClass,
BClass->CClass.
但是这种方案拷贝了多次效率低下，而且其中不需要的name也在AClass->BClass的时候拷贝了

>考虑先分析再拷贝，直接从AClass->CClass拷贝
算法分析：
    1. 第一种方案，直接拷贝C中需要拷贝的 且 AClass中含有的值。这时候type没有拷贝，需要警告。
    即拷贝问题变为AClass->CClass拷贝。
### 同类拷贝问题
1. 同级 引用 --- 这种
```java
class AClass{
    String name;
    Object obj1;
    Object obj2;
}
```
```java
AClass a = new AClass();
a.obj1 = new Object();           
a.obj2 = obj1;          // 引用同级元素
AClass newA = clone(a); // 拷贝同类
```
>只拷贝一份值，其余拷贝引用。）需要将类的属性全部保存，每次拷贝前查询是否引用了当前类）
2. 父级引用
```java
class AClass{
    String name;
    AClass aClass;
}
```
```java
AClass a = new AClass();
a.aClass = a;
AClass newA = clone(a); // 拷贝同类
```
或者更多层后成环
```java
AClass a = new AClass();
a.aClass = new AClass(); 
a.aClass.aClass = a;    // 环形引用自身a.aClass->b, b.aClass->a
AClass newA = clone(a); // 拷贝同类
```
>解决方案，在发现环时拷贝引用 
对于（1）拷贝a的引用给a.aClass
对于（2）拷贝a的引用给b.aClass
