```java
// A copy to B
A class{
    String a;
    int b;
    int cd;
}
// copy form A
B class{
    String a;// A.a
    int b;// A.b
    int c;// A.c // have not c
}
```
1. 在编译期间检查A,B映射关系B->A, 如果A中找不到B的属性映射报错

检查成功后，运行时实现copy A to B

2. 通过反射实现任意的A copy to B
    
    1. 需要的已知信息 A的类型AClass，B的类型BClass 
        
        
        考虑如下实现方式：
        1. B b = CopyUtil.copy(A, BClass);// 直接通过工具类调用         √
        2. B b = new A().copy(BClass);// A中有某个方法，此方法再调用1.  
        3. B b = new A().copy(BClass);// A中有某个方法，此方法被动态代理并拦截下来
        4. User user = new AnyObject().coverToUser(); // 考虑在给定方法coverToUser上添加注解，然后扫描这个注解。通过注解内容获取目标类，然后代理这个方法并返回User对象。也就是将BClass信息添加到注解上。然后通过代理实现。
            1. User user = CopyProxy.poxy(new AnyObject()).coverToUser();// 返回了被代理后的AnyObject
            2. User user = new A().copyToUser();                    √
            // copyToUser: 内部调用CopyUtil.copy(this, User)    
    2. copy 需要已知 B的字段集合BFields, A的字段集合AFields             √
        同类对象
            1. 实现序列化接口，直接使用IO流                             √
            2. 否则利用反射，递归copy（目前只实现了浅拷贝）

        不同类对象
        实现步骤：
        1. 获取到BFields 中需要拷贝的字段BFieldsNeeded
        2. 实例化B 前提：类B必须要有默认无参构造方法，否则无法完成拷贝
        3. 拷贝各个字段f[1...n]
            1. 对于每个字段f[i]，找出在A中的字段（这里先不判断不能找到，假设一定能找到）
            2. 拷贝值 
        4. 返回拷贝结果




